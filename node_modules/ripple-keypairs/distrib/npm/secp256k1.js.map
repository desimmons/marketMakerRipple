{"version":3,"sources":["../../src/secp256k1.js"],"names":[],"mappings":"AAAA,YAAY,CAAA;;AAEZ,IAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,CAAC,CAAA;AACpC,IAAM,SAAS,GAAG,QAAQ,CAAC,EAAE,CAAC,WAAW,CAAC,CAAA;AAC1C,IAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAA;;AAElC,SAAS,YAAY,CAAC,KAAK,EAAE,OAAO,EAAE;AACpC,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAA;AAC/B,OAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,UAAU,EAAE,CAAC,EAAE,EAAE;;;AAGpC,QAAM,MAAM,GAAG,IAAI,MAAM,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;;AAEtC,QAAI,OAAO,KAAK,SAAS,EAAE;AACzB,YAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;KACvB;AACD,UAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;AAChB,QAAM,GAAG,GAAG,MAAM,CAAC,UAAU,EAAE,CAAA;AAC/B,QAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AACzC,aAAO,GAAG,CAAA;KACX;GACF;AACD,QAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAA;CACzC;;;;;;;;;;;AAWD,SAAS,gBAAgB,CAAC,IAAI,EAAa;MAAX,IAAI,yDAAG,EAAE;;AACvC,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAA;AAC3B,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAA;;;;AAI/B,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AACrC,MAAI,IAAI,EAAE;;AAER,WAAO,UAAU,CAAA;GAClB;AACD,MAAM,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;;;AAG7C,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,CAAC,CAAA;AAC3C,SAAO,YAAY,CAAC,SAAS,CAAC,gBAAgB,EAAE,EAAE,YAAY,CAAC,CACpD,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;CACtC;;AAED,SAAS,gCAAgC,CAAC,cAAc,EAAE;AACxD,MAAM,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC,cAAc,CAAC,CAAA;AAChE,MAAM,MAAM,GAAG,YAAY,CAAC,cAAc,EAAE,CAAC,CAAC,CAAA;AAC9C,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AACrC,MAAM,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;AACtC,SAAO,MAAM,CAAC,gBAAgB,EAAE,CAAA;CACjC;;AAED,MAAM,CAAC,OAAO,GAAG;AACf,kBAAgB,EAAhB,gBAAgB;AAChB,kCAAgC,EAAhC,gCAAgC;CACjC,CAAA","file":"secp256k1.js","sourcesContent":["'use strict' // eslint-disable-line strict\n\nconst elliptic = require('elliptic')\nconst secp256k1 = elliptic.ec('secp256k1')\nconst Sha512 = require('./sha512')\n\nfunction deriveScalar(bytes, discrim) {\n  const order = secp256k1.curve.n\n  for (let i = 0; i <= 0xFFFFFFFF; i++) {\n    // We hash the bytes to find a 256 bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512().add(bytes)\n    // If the optional discriminator index was passed in, update the hash.\n    if (discrim !== undefined) {\n      hasher.addU32(discrim)\n    }\n    hasher.addU32(i)\n    const key = hasher.first256BN()\n    if (key.cmpn(0) > 0 && key.cmp(order) < 0) {\n      return key\n    }\n  }\n  throw new Error('impossible unicorn ;)')\n}\n\n/**\n* @param {Array} seed - bytes\n* @param {Object} [opts] - object\n* @param {Number} [opts.accountIndex=0] - the account number to generate\n* @param {Boolean} [opts.validator=false] - generate root key-pair,\n*                                              as used by validators.\n* @return {bn.js} - 256 bit scalar value\n*\n*/\nfunction derivePrivateKey(seed, opts = {}) {\n  const root = opts.validator\n  const order = secp256k1.curve.n\n\n  // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n  const privateGen = deriveScalar(seed)\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen\n  }\n  const publicGen = secp256k1.g.mul(privateGen)\n  // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n  const accountIndex = opts.accountIndex || 0\n  return deriveScalar(publicGen.encodeCompressed(), accountIndex)\n            .add(privateGen).mod(order)\n}\n\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n  const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes)\n  const scalar = deriveScalar(publicGenBytes, 0)\n  const point = secp256k1.g.mul(scalar)\n  const offset = rootPubPoint.add(point)\n  return offset.encodeCompressed()\n}\n\nmodule.exports = {\n  derivePrivateKey,\n  accountPublicFromPublicGenerator\n}\n"]}